#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>



// plan 짜기! 일단 최적 경로는 한개임. 
// 헷갈리는데, 가는 경로에 다른 포인트가 존재해도 상관 없음. 따라서 그냥 경로는 여러개가 아니라 한 개임. 
// 그럼 일단 모든 로봇에 대해서 그냥 일단 경로별로 시간과 위치를 쭉 출력하면 되는 듯. 

// 일단 모든 로봇에 대해서 경로를 만들 것임.  [[[시간, 해당 시간 r, 해당 시간 c], ...로봇이 움직인 시간만큼 ]...로봇 갯수만큼]
// 방법은 for문을 돌려서 로봇 1부터 로봇 x까지 돌림. 시뮬레이션 시간은 0으로 시작
// 로봇 1번부터 보면, 한 위치에서 다음 위치 확인하고, 움직이는 경로를 쭉 만들어서 경로에 업데이트함. 시간 +1은 계속 해줌. 
// 그리고 로봇이 타겟까지 움직이는 것을 완료하는 순간 시간을 계산해서 시간 배열에 넣을 것임. time_moved = [로봇 갯수만큼]

// 그리고 시간 배열의 최댓값 만큼 for 문 돌면서 배열에 시간이랑 r, c가 겹치는게 있는지 확인. 만일 겹친다면 충돌 +1

//////////////////////////////////재설계/////////////////////////////////////////////////////////



// 아니, 그보단 시간별로 좌표를 넣는게 나을 것 같은데..? 
// 일단 모든 로봇에 대해서 경로를 만들 것임.  [[해당 시간 r, 해당 시간 c], ...해당 시간에 로봇들이 있는 위치를 전부 집어넣음]...최종 시간만큼]
// for문을 돌려서 로봇 1부터 로봇 x까지 돌림. 시뮬레이션 시간은 0으로 시작
// 로봇 1번부터 보면, 한 위치에서 다음 위치 확인하고, 움직이는 경로를 쭉 만들어서 로봇 경로 배열에 넣음. 어떤 로봇인지는 몰라도 되니, 그냥 위치만 넣음. 시간 +1은 계속 해줌. 
// 그리고 경로 배열을 1부터 최종 시간(배열 길이)만큼 돌면서 동일 r, c가 있는지 확인! 
// 동일 r, c는 일케 계산한다.
// 시간마다 201크기의 배열을 0으로 재셋팅 한다.
// 그리고 r+100c로 배열에 표기한다. 2가 되는 순간 카운트는 하나가 올라간다. 2 이상인 경우는 카운트 하지 않는다. 
// 

// points_rows는 2차원 배열 points의 행 길이, points_cols는 2차원 배열 points의 열 길이입니다.
// routes_rows는 2차원 배열 routes의 행 길이, routes_cols는 2차원 배열 routes의 열 길이입니다.
int solution(int** points, size_t points_rows, size_t points_cols, int** routes, size_t routes_rows, size_t routes_cols) {
    int answer = 0;
    int *root;
    int time_end; // 이건 최종 시간...혹시 몰라 추가한 변수이니 필요 없다면 그냥 제외해도 됨. 
    root = (int*)malloc(sizeof(int)*10000); // 이거 size of 를 일케 잡긴 했는데 숫자를 좀 더 줄일 수 있나 생각해봐야 함.....

    for(int i=0;i<routes_rows; i++){
        if  // 아니 근데 로봇 번호를 신경을 안쓸수가 없는게 열을 어케암.
    }

    return answer;
}




